%module{Slic3r::XS};

#include <xsinit.h>
#include "slic3r/GUI/GLShader.hpp"
#include "slic3r/GUI/3DScene.hpp"

%name{Slic3r::GUI::_3DScene::GLShader} class GLShader {
    GLShader();
    ~GLShader();

    bool load_from_text(const char *fragment_shader, const char *vertex_shader);
    bool load_from_file(const char *fragment_shader, const char *vertex_shader);
    void release();

    int  get_attrib_location(const char *name) const;
    int  get_uniform_location(const char *name) const;

    bool set_uniform(const char *name, float value) const;

    void enable() const;
    void disable() const;

    int shader_program_id() const
        %code%{ RETVAL = THIS->shader_program_id; %};

    std::string last_error() const
        %code%{ RETVAL = THIS->last_error; %};
};

%name{Slic3r::GUI::_3DScene::GLVolume} class GLVolume {
    GLVolume();
    ~GLVolume();

    std::vector<double> color()
        %code%{ RETVAL.reserve(4); RETVAL.push_back(THIS->color[0]); RETVAL.push_back(THIS->color[1]); RETVAL.push_back(THIS->color[2]); RETVAL.push_back(THIS->color[3]); %};

    int                 select_group_id()
        %code%{ RETVAL = THIS->select_group_id; %};
    int                 drag_group_id()
        %code%{ RETVAL = THIS->drag_group_id; %};
    int                 selected()
        %code%{ RETVAL = THIS->selected; %};
    void                set_selected(int i)
        %code%{ THIS->selected = i; %};
    int                 hover()
        %code%{ RETVAL = THIS->hover; %};
    void                set_hover(int i)
        %code%{ THIS->hover = i; %};
    int                 zoom_to_volumes()
        %code%{ RETVAL = THIS->zoom_to_volumes; %};

    void set_layer_height_texture_data(unsigned int texture_id, unsigned int shader_id, PrintObject* print_object, float z_cursor_relative, float edit_band_width);
    void reset_layer_height_texture_data();

    int                 object_idx() const;
    int                 volume_idx() const;
    int                 instance_idx() const;
    Clone<Pointf3>      origin() const
        %code%{ RETVAL = THIS->origin; %};
    void                translate(double x, double y, double z)
        %code%{ THIS->origin.translate(x, y, z); %};
    Clone<BoundingBoxf3> bounding_box() const
        %code%{ RETVAL = THIS->bounding_box; %};
    Clone<BoundingBoxf3> transformed_bounding_box() const;

    bool                empty() const;
    bool                indexed() const;

    void                render() const;

    bool                has_layer_height_texture();
    int                 layer_height_texture_width();
    int                 layer_height_texture_height();
    int                 layer_height_texture_cells();
    void*               layer_height_texture_data_ptr_level0();
    void*               layer_height_texture_data_ptr_level1();
    double              layer_height_texture_z_to_row_id() const; 
    void                generate_layer_height_texture(PrintObject *print_object, bool force);
};


%name{Slic3r::GUI::_3DScene::GLVolume::Collection} class GLVolumeCollection {
    GLVolumeCollection();
    ~GLVolumeCollection();

    std::vector<int> load_object(ModelObject *object, int obj_idx, std::vector<int> instance_idxs, std::string color_by, std::string select_by, std::string drag_by, bool use_VBOs);

    int load_wipe_tower_preview(int obj_idx, float pos_x, float pos_y, float width, float depth, float height, float rotation_angle, bool use_VBOs);

    void erase()
        %code{% THIS->clear(); %};

    int count()
        %code{% RETVAL = THIS->volumes.size(); %};
        
    std::vector<double> get_current_print_zs(bool active_only)
        %code{% RETVAL = THIS->get_current_print_zs(active_only); %};

    void set_range(double low, double high);

    void render_VBOs() const;
    void render_legacy() const;
    void finalize_geometry(bool use_VBOs);
    void release_geometry();

    void set_print_box(float min_x, float min_y, float min_z, float max_x, float max_y, float max_z);
    bool check_outside_state(DynamicPrintConfig* config)
        %code%{ 
                RETVAL = THIS->check_outside_state(config);
        %};
    
    void reset_outside_state();    
    void update_colors_by_extruder(DynamicPrintConfig* config);

    bool move_volume_up(int idx)
        %code%{ 
            if (idx > 0 && idx < int(THIS->volumes.size())) {
                std::swap(THIS->volumes[idx-1], THIS->volumes[idx]);
                std::swap(THIS->volumes[idx-1]->composite_id,    THIS->volumes[idx]->composite_id);
                std::swap(THIS->volumes[idx-1]->select_group_id, THIS->volumes[idx]->select_group_id);
                std::swap(THIS->volumes[idx-1]->drag_group_id,   THIS->volumes[idx]->drag_group_id);
                RETVAL = true;
            } else
                RETVAL = false;
        %};
    bool move_volume_down(int idx)
        %code%{ 
            if (idx >= 0 && idx + 1 < int(THIS->volumes.size())) {
                std::swap(THIS->volumes[idx+1], THIS->volumes[idx]);
                std::swap(THIS->volumes[idx+1]->composite_id,    THIS->volumes[idx]->composite_id);
                std::swap(THIS->volumes[idx+1]->select_group_id, THIS->volumes[idx]->select_group_id);
                std::swap(THIS->volumes[idx+1]->drag_group_id,   THIS->volumes[idx]->drag_group_id);
                RETVAL = true;
            } else
                RETVAL = false;
        %};

%{

SV*
GLVolumeCollection::arrayref()
    CODE:
        AV* av = newAV();
        av_fill(av, THIS->volumes.size()-1);
        int i = 0;
        for (GLVolume *v : THIS->volumes) {
            av_store(av, i++, perl_to_SV_ref(*v));
        }
        RETVAL = newRV_noinc((SV*)av);
    OUTPUT:
        RETVAL

%}
};

%package{Slic3r::GUI::_3DScene};
%{

void
init_gl()
    CODE:
        _3DScene::init_gl();

bool
use_VBOs()
    CODE:
        RETVAL = _3DScene::use_VBOs();
    OUTPUT:
        RETVAL
        
bool
add_canvas(canvas, context)
        SV *canvas;
        SV *context;
    CODE:
        RETVAL = _3DScene::add_canvas((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), (wxGLContext*)wxPli_sv_2_object(aTHX_ context, "Wx::GLContext"));
    OUTPUT:
        RETVAL

bool
remove_canvas(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::remove_canvas((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
remove_all_canvases()
    CODE:
        _3DScene::remove_all_canvases();

bool
init(canvas, useVBOs)
        SV   *canvas;
        bool useVBOs;
    CODE:
        RETVAL = _3DScene::init((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), useVBOs);
    OUTPUT:
        RETVAL

bool
is_dirty(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::is_dirty((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_dirty(canvas, dirty)
        SV   *canvas;
        bool dirty;
    CODE:
        _3DScene::set_dirty((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), dirty);

bool
is_shown_on_screen(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::is_shown_on_screen((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
resize(canvas, w, h)
        SV           *canvas;
        unsigned int w;
        unsigned int h;
    CODE:
        _3DScene::resize((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), w, h);
        
GLVolumeCollection*
get_volumes(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_volumes((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_volumes(canvas, volumes)
        SV                 *canvas;
        GLVolumeCollection *volumes;
    CODE:
        _3DScene::set_volumes((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), volumes);

void
reset_volumes(canvas)
        SV *canvas;
    CODE:
        _3DScene::reset_volumes((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));

void
deselect_volumes(canvas)
        SV *canvas;
    CODE:
        _3DScene::deselect_volumes((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));

void
select_volume(canvas, id)
        SV           *canvas;
        unsigned int id;
    CODE:
        _3DScene::select_volume((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), id);

void
set_config(canvas, config)
        SV                 *canvas;
        DynamicPrintConfig *config;
    CODE:
        _3DScene::set_config((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), config);

void
set_print(canvas, print)
        SV    *canvas;
        Print *print;
    CODE:
        _3DScene::set_print((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), print);

void
set_bed_shape(canvas, shape)
        SV      *canvas;
        Pointfs shape;
    CODE:
        _3DScene::set_bed_shape((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), shape);

void
set_auto_bed_shape(canvas)
        SV *canvas;
    CODE:
        _3DScene::set_auto_bed_shape((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));

Clone<BoundingBoxf3>
get_bed_bounding_box(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_bed_bounding_box((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

Clone<BoundingBoxf3>
get_volumes_bounding_box(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_volumes_bounding_box((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL
        
Clone<BoundingBoxf3>
get_max_bounding_box(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_max_bounding_box((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL
        
Clone<Pointf3>
get_axes_origin(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_axes_origin((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_axes_origin(canvas, origin)
        SV      *canvas;
        Pointf3 *origin;
    CODE:
        _3DScene::set_axes_origin((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), origin);

float
get_axes_length(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_axes_length((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_axes_length(canvas, length)
        SV    *canvas;
        float length;
    CODE:
        _3DScene::set_axes_length((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), length);

void
set_cutting_plane(canvas, z, polygons)
        SV         *canvas;
        float      z;
        ExPolygons polygons;
    CODE:
        _3DScene::set_cutting_plane((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), z, polygons);
        
unsigned int
get_camera_type(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_camera_type((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_camera_type(canvas, type)
        SV *canvas;
        unsigned int type;
    CODE:
        _3DScene::set_camera_type((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), type);

std::string
get_camera_type_as_string(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_camera_type_as_string((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

float
get_camera_zoom(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_camera_zoom((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_camera_zoom(canvas, zoom)
        SV    *canvas;
        float zoom;
    CODE:
        _3DScene::set_camera_zoom((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), zoom);

float
get_camera_phi(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_camera_phi((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_camera_phi(canvas, phi)
        SV    *canvas;
        float phi;
    CODE:
        _3DScene::set_camera_phi((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), phi);

float
get_camera_theta(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_camera_theta((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_camera_theta(canvas, theta)
        SV    *canvas;
        float theta;
    CODE:
        _3DScene::set_camera_theta((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), theta);

float
get_camera_distance(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_camera_distance((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_camera_distance(canvas, distance)
        SV    *canvas;
        float distance;
    CODE:
        _3DScene::set_camera_distance((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), distance);

Clone<Pointf3>
get_camera_target(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_camera_target((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_camera_target(canvas, target)
        SV      *canvas;
        Pointf3 *target;
    CODE:
        _3DScene::set_camera_target((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), target);

bool
is_layers_editing_enabled(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::is_layers_editing_enabled((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

bool
is_picking_enabled(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::is_picking_enabled((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

bool
is_layers_editing_allowed(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::is_layers_editing_allowed((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL
        
bool
is_multisample_allowed(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::is_multisample_allowed((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
enable_layers_editing(canvas, enable)
        SV   *canvas;
        bool enable;
    CODE:
        _3DScene::enable_layers_editing((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), enable);
    
void
enable_warning_texture(canvas, enable)
        SV   *canvas;
        bool enable;
    CODE:
        _3DScene::enable_warning_texture((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), enable);
    
void
enable_legend_texture(canvas, enable)
        SV   *canvas;
        bool enable;
    CODE:
        _3DScene::enable_legend_texture((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), enable);
    
void
enable_picking(canvas, enable)
        SV   *canvas;
        bool enable;
    CODE:
        _3DScene::enable_picking((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), enable);

void
enable_shader(canvas, enable)
        SV   *canvas;
        bool enable;
    CODE:
        _3DScene::enable_shader((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), enable);

void
allow_multisample(canvas, allow)
        SV   *canvas;
        bool allow;
    CODE:
        _3DScene::allow_multisample((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), allow);
        
bool
is_mouse_dragging(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::is_mouse_dragging((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_mouse_dragging(canvas, dragging)
        SV   *canvas;
        bool dragging;
    CODE:
        _3DScene::set_mouse_dragging((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), dragging);

Clone<Pointf>
get_mouse_position(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_mouse_position((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_mouse_position(canvas, position)
        SV     *canvas;
        Pointf *position;
    CODE:
        _3DScene::set_mouse_position((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), position);

int
get_hover_volume_id(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_hover_volume_id((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_hover_volume_id(canvas, id)
        SV  *canvas;
        int id;
    CODE:
        _3DScene::set_hover_volume_id((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), id);

unsigned int
get_layers_editing_z_texture_id(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_layers_editing_z_texture_id((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

float
get_layers_editing_band_width(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_layers_editing_band_width((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_layers_editing_band_width(canvas, band_width)
        SV    *canvas;
        float band_width;
    CODE:
        _3DScene::set_layers_editing_band_width((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), band_width);

float
get_layers_editing_strength(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_layers_editing_strength((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_layers_editing_strength(canvas, strength)
        SV    *canvas;
        float strength;
    CODE:
        _3DScene::set_layers_editing_strength((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), strength);

int
get_layers_editing_last_object_id(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_layers_editing_last_object_id((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_layers_editing_last_object_id(canvas, id)
        SV  *canvas;
        int id;
    CODE:
        _3DScene::set_layers_editing_last_object_id((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), id);

float
get_layers_editing_last_z(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_layers_editing_last_z((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_layers_editing_last_z(canvas, z)
        SV    *canvas;
        float z;
    CODE:
        _3DScene::set_layers_editing_last_z((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), z);

unsigned int
get_layers_editing_last_action(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_layers_editing_last_action((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
set_layers_editing_last_action(canvas, action)
        SV           *canvas;
        unsigned int action;
    CODE:
        _3DScene::set_layers_editing_last_action((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), action);

Ref<GLShader>
get_layers_editing_shader(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_layers_editing_shader((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

float
get_layers_editing_cursor_z_relative(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::get_layers_editing_cursor_z_relative((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

int
get_layers_editing_first_selected_object_id(canvas, objects_count)
        SV           *canvas;
        unsigned int objects_count;
    CODE:
        RETVAL = _3DScene::get_layers_editing_first_selected_object_id((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), objects_count);
    OUTPUT:
        RETVAL

bool
bar_rect_contains(canvas, x, y)
        SV *canvas;
        float x;
        float y;
    CODE:
        RETVAL = _3DScene::bar_rect_contains((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), x, y);
    OUTPUT:
        RETVAL

bool
reset_rect_contains(canvas, x, y)
        SV    *canvas;
        float x;
        float y;
    CODE:
        RETVAL = _3DScene::reset_rect_contains((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), x, y);
    OUTPUT:
        RETVAL

void
zoom_to_bed(canvas)
        SV *canvas;
    CODE:
        _3DScene::zoom_to_bed((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));

void
zoom_to_volumes(canvas)
        SV *canvas;
    CODE:
        _3DScene::zoom_to_volumes((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    
void
select_view(canvas, direction)
        SV          *canvas;
        std::string direction;
    CODE:
        _3DScene::select_view((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), direction);

void
update_volumes_colors_by_extruder(canvas)
        SV *canvas;
    CODE:
        _3DScene::update_volumes_colors_by_extruder((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));

bool
start_using_shader(canvas)
        SV *canvas;
    CODE:
        RETVAL = _3DScene::start_using_shader((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));
    OUTPUT:
        RETVAL

void
stop_using_shader(canvas)
        SV *canvas;
    CODE:
        _3DScene::stop_using_shader((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));

void
render(canvas)
        SV *canvas;
    CODE:
        _3DScene::render((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"));

void
render_volumes(canvas, fake_colors)
        SV   *canvas;
        bool fake_colors;
    CODE:
        _3DScene::render_volumes((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), fake_colors);

void
render_texture(canvas, tex_id, left, right, bottom, top)
        SV           *canvas;
        unsigned int tex_id;
        float        left;
        float        right;
        float        bottom;
        float        top;
    CODE:
        _3DScene::render_texture((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), tex_id, left, right, bottom, top);

void
register_on_viewport_changed_callback(canvas, callback)
        SV *canvas;
        SV *callback;
    CODE:
        _3DScene::register_on_viewport_changed_callback((wxGLCanvas*)wxPli_sv_2_object(aTHX_ canvas, "Wx::GLCanvas"), (void*)callback);
    
    
    
unsigned int
finalize_legend_texture()
    CODE:
        RETVAL = _3DScene::finalize_legend_texture();
    OUTPUT:
        RETVAL

unsigned int
get_legend_texture_width()
    CODE:
        RETVAL = _3DScene::get_legend_texture_width();
    OUTPUT:
        RETVAL

unsigned int
get_legend_texture_height()
    CODE:
        RETVAL = _3DScene::get_legend_texture_height();
    OUTPUT:
        RETVAL
             
void
reset_legend_texture()
    CODE:
        _3DScene::reset_legend_texture();

void
generate_warning_texture(std::string msg)
    CODE:
        _3DScene::generate_warning_texture(msg);

unsigned int
finalize_warning_texture()
    CODE:
        RETVAL = _3DScene::finalize_warning_texture();
    OUTPUT:
        RETVAL

unsigned int
get_warning_texture_width()
    CODE:
        RETVAL = _3DScene::get_warning_texture_width();
    OUTPUT:
        RETVAL

unsigned int
get_warning_texture_height()
    CODE:
        RETVAL = _3DScene::get_warning_texture_height();
    OUTPUT:
        RETVAL

void
reset_warning_texture()
    CODE:
        _3DScene::reset_warning_texture();

void
_load_print_toolpaths(print, volumes, tool_colors, use_VBOs)
        Print               *print;
        GLVolumeCollection  *volumes;
        std::vector<std::string> tool_colors;
        int                  use_VBOs;
    CODE:
        _3DScene::_load_print_toolpaths(print, volumes, tool_colors, use_VBOs != 0);

void 
_load_print_object_toolpaths(print_object, volumes, tool_colors, use_VBOs)
        PrintObject        *print_object;
        GLVolumeCollection *volumes;
        std::vector<std::string> tool_colors;
        int                 use_VBOs;
    CODE:
        _3DScene::_load_print_object_toolpaths(print_object, volumes, tool_colors, use_VBOs != 0);

void
_load_wipe_tower_toolpaths(print, volumes, tool_colors, use_VBOs)
        Print               *print;
        GLVolumeCollection  *volumes;
        std::vector<std::string> tool_colors;
        int                  use_VBOs;
    CODE:
        _3DScene::_load_wipe_tower_toolpaths(print, volumes, tool_colors, use_VBOs != 0);

void 
load_gcode_preview(print, preview_data, volumes, str_tool_colors, use_VBOs)
        Print                    *print;
        GCodePreviewData         *preview_data;
        GLVolumeCollection       *volumes;
        std::vector<std::string> str_tool_colors;
        int                      use_VBOs;
    CODE:
        _3DScene::load_gcode_preview(print, preview_data, volumes, str_tool_colors, use_VBOs != 0);
        
%}
